{"noir_version":"0.37.0+5ae0dfc11f4aa9e806cfa533571848c1361a7c7c","hash":6510605224854996040,"abi":{"parameters":[{"name":"address_u8","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"address_field","type":{"kind":"field"},"visibility":"private"},{"name":"address_owners","type":{"kind":"array","length":50,"type":{"kind":"field"}},"visibility":"public"},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"expected_message","type":{"kind":"array","length":38,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"26":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\nfn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        let input = \"Hello world!\".as_bytes();\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n\n    #[test]\n    fn hash_longer_than_136_bytes() {\n        let input = \"123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789\"\n            .as_bytes();\n        assert(input.len() > 136);\n\n        let result = [\n            0x1d, 0xca, 0xeb, 0xdf, 0xd9, 0xd6, 0x24, 0x67, 0x1c, 0x18, 0x16, 0xda, 0xd, 0x8a, 0xeb,\n            0xa8, 0x75, 0x71, 0x2c, 0xc, 0x89, 0xe0, 0x25, 0x2, 0xe8, 0xb6, 0x5e, 0x16, 0x5, 0x55,\n            0xe4, 0x40,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n}\n","path":"std/hash/keccak.nr"},"28":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"34":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8 = 256;\nglobal TWO_POW_16 = TWO_POW_8 * 256;\nglobal TWO_POW_24 = TWO_POW_16 * 256;\nglobal TWO_POW_32 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"69":{"source":"fn is_element_in_set(element: Field, set: [Field; 50]) -> bool {\n    let mut result: bool = false;\n    for i in 0..set.len() {\n        if (element == set[i]) {\n            result = true;\n        }\n    }\n    result\n}\n\nfn main(address_u8: [u8; 20],\n        address_field: Field,\n        address_owners: pub [Field; 50],\n        pub_key_x: [u8;32],\n        pub_key_y: [u8;32],\n        signature: [u8;64],\n        hashed_message: pub [u8; 32],\n        expected_message: pub [u8; 38] // Should change to 1 for \"X\"\n){\n     // Check inclusion\n     assert(is_element_in_set(address_field, address_owners));\n\n     // Check address coincidence\n      let mut reconstructed_address: Field = 0;\n      for i in 0..address_u8.len() {\n          reconstructed_address = (reconstructed_address * 256) + (address_u8[i] as Field);\n      }\n      assert(address_field == reconstructed_address);\n\n     // Check message coincidence\n     assert(std::hash::sha256_var(expected_message, 38) == hashed_message);\n\n     // Verifies that the prover is owner of the private key\n     // Prover is requested to send the message \"X\" hashed, so it might be possible to use a hardcoded hashed_message\n\n      let valid_signature = std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, signature, hashed_message);\n      assert(valid_signature);\n\n     //Verifies that the prover's public key derives to the address\n      let mut full_public_key: [u8; 64] = [0; 64];\n      for i in 0..32 {\n          full_public_key[i] = pub_key_x[i];\n      }\n      for i in 0..32 {\n          full_public_key[32 + i] = pub_key_y[i];\n      }\n      let hash = std::hash::keccak256(full_public_key, 64);\n      let mut derived_address: [u8; 20] = [0; 20];\n      for i in 0..20 {\n          derived_address[i] = hash[12+i];\n      }\n      assert(address_u8 == derived_address);\n}\n\n#[test]\nfn test() {\n    let expected_message = [0x49, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x75, 0x6e, 0x63, 0x6c, 0x65, 0x61, 0x72, 0x2c, 0x20, 0x61, 0x73, 0x6b, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x2e, ];\n    let address_field = 0x4cceba2d7d2b4fdce4304d3e09a1fea9fbeb1528;\n    let address_owners = [\n        1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x4cceba2d7d2b4fdce4304d3e09a1fea9fbeb1528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    ];\n\n    let address_u8 =[76, 206, 186, 45, 125, 43, 79, 220, 228, 48, 77, 62, 9, 161, 254, 169, 251, 235, 21, 40];\n    let hashed_message = [ 0x3a, 0x73, 0xf4, 0x12, 0x3a, 0x5c, 0xd2, 0x12, 0x1f, 0x21, 0xcd, 0x7e, 0x8d, 0x35, 0x88, 0x35, 0x47, 0x69, 0x49, 0xd0, 0x35, 0xd9, 0xc2, 0xda, 0x68, 0x06, 0xb4, 0x63, 0x3a, 0xc8, 0xc1, 0xe2, ];\n    let pub_key_x = [ 0xa0, 0x43, 0x4d, 0x9e, 0x47, 0xf3, 0xc8, 0x62, 0x35, 0x47, 0x7c, 0x7b, 0x1a, 0xe6, 0xae, 0x5d, 0x34, 0x42, 0xd4, 0x9b, 0x19, 0x43, 0xc2, 0xb7, 0x52, 0xa6, 0x8e, 0x2a, 0x47, 0xe2, 0x47, 0xc7, ];\n    let pub_key_y = [ 0x89, 0x3a, 0xba, 0x42, 0x54, 0x19, 0xbc, 0x27, 0xa3, 0xb6, 0xc7, 0xe6, 0x93, 0xa2, 0x4c, 0x69, 0x6f, 0x79, 0x4c, 0x2e, 0xd8, 0x77, 0xa1, 0x59, 0x3c, 0xbe, 0xe5, 0x3b, 0x03, 0x73, 0x68, 0xd7, ];\n    let signature = [ 0xe5, 0x08, 0x1c, 0x80, 0xab, 0x42, 0x7d, 0xc3, 0x70, 0x34, 0x6f, 0x4a, 0x0e, 0x31, 0xaa, 0x2b, 0xad, 0x8d, 0x97, 0x98, 0xc3, 0x80, 0x61, 0xdb, 0x9a, 0xe5, 0x5a, 0x4e, 0x8d, 0xf4, 0x54, 0xfd, 0x28, 0x11, 0x98, 0x94, 0x34, 0x4e, 0x71, 0xb7, 0x87, 0x70, 0xcc, 0x93, 0x1d, 0x61, 0xf4, 0x80, 0xec, 0xbb, 0x0b, 0x89, 0xd6, 0xeb, 0x69, 0x69, 0x01, 0x61, 0xe4, 0x9a, 0x71, 0x5f, 0xcd, 0x55, ];\n\n    main(address_u8, address_field, address_owners, pub_key_x, pub_key_y, signature, hashed_message, expected_message);\n}\n\n#[test(should_fail)]\nfn test_fail() {\n    let expected_message = [0x49, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x75, 0x6e, 0x63, 0x6c, 0x65, 0x61, 0x72, 0x2c, 0x20, 0x61, 0x73, 0x6b, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x2e, ];\n    let address_field = 0x4cceba2d7d2b4fdce4304d9e09a1fea9fbeb1528;\n    let address_owners = [\n        1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x4cceba2d7d2b4fdce4304d3e09a1fea9fbeb1528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    ];\n\n    let address_u8 =[76, 206, 186, 45, 125, 43, 79, 220, 228, 48, 77, 62, 9, 161, 254, 169, 251, 235, 21, 40];\n    let hashed_message = [ 0x3a, 0x73, 0xf4, 0x12, 0x3a, 0x5c, 0xd2, 0x12, 0x1f, 0x21, 0xcd, 0x7e, 0x8d, 0x35, 0x88, 0x35, 0x47, 0x69, 0x49, 0xd0, 0x35, 0xd9, 0xc2, 0xda, 0x68, 0x06, 0xb4, 0x63, 0x3a, 0xc8, 0xc1, 0xe2, ];\n    let pub_key_x = [ 0xa0, 0x43, 0x4d, 0x9e, 0x47, 0xf3, 0xc8, 0x62, 0x35, 0x47, 0x7c, 0x7b, 0x1a, 0xe6, 0xae, 0x5d, 0x34, 0x42, 0xd4, 0x9b, 0x19, 0x43, 0xc2, 0xb7, 0x52, 0xa6, 0x8e, 0x2a, 0x47, 0xe2, 0x47, 0xc7, ];\n    let pub_key_y = [ 0x89, 0x3a, 0xba, 0x42, 0x54, 0x19, 0xbc, 0x27, 0xa3, 0xb6, 0xc7, 0xe6, 0x93, 0xa2, 0x4c, 0x69, 0x6f, 0x79, 0x4c, 0x2e, 0xd8, 0x77, 0xa1, 0x59, 0x3c, 0xbe, 0xe5, 0x3b, 0x03, 0x73, 0x68, 0xd7, ];\n    let signature = [ 0xe5, 0x08, 0x1c, 0x80, 0xab, 0x42, 0x7d, 0xc3, 0x70, 0x34, 0x6f, 0x4a, 0x0e, 0x31, 0xaa, 0x2b, 0xad, 0x8d, 0x97, 0x98, 0xc3, 0x80, 0x61, 0xdb, 0x9a, 0xe5, 0x5a, 0x4e, 0x8d, 0xf4, 0x54, 0xfd, 0x28, 0x11, 0x98, 0x94, 0x34, 0x4e, 0x71, 0xb7, 0x87, 0x70, 0xcc, 0x93, 0x1d, 0x61, 0xf4, 0x80, 0xec, 0xbb, 0x0b, 0x89, 0xd6, 0xeb, 0x69, 0x69, 0x01, 0x61, 0xe4, 0x9a, 0x71, 0x5f, 0xcd, 0x55, ];\n\n    main(address_u8, address_field, address_owners, pub_key_x, pub_key_y, signature, hashed_message, expected_message);\n}","path":"/home/bweisz/Documentos/devcon/proof-of-poap-circuits/circuits/src/main.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","directive_invert","directive_integer_quotient"]}