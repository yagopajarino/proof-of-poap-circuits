{"noir_version":"0.37.0+5ae0dfc11f4aa9e806cfa533571848c1361a7c7c","hash":30116833690446611,"abi":{"parameters":[{"name":"address_u8","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"address_field","type":{"kind":"field"},"visibility":"private"},{"name":"address_owners","type":{"kind":"array","length":50,"type":{"kind":"field"}},"visibility":"private"},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"expected_message","type":{"kind":"array","length":38,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"26":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\nfn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        let input = \"Hello world!\".as_bytes();\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n\n    #[test]\n    fn hash_longer_than_136_bytes() {\n        let input = \"123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789\"\n            .as_bytes();\n        assert(input.len() > 136);\n\n        let result = [\n            0x1d, 0xca, 0xeb, 0xdf, 0xd9, 0xd6, 0x24, 0x67, 0x1c, 0x18, 0x16, 0xda, 0xd, 0x8a, 0xeb,\n            0xa8, 0x75, 0x71, 0x2c, 0xc, 0x89, 0xe0, 0x25, 0x2, 0xe8, 0xb6, 0x5e, 0x16, 0x5, 0x55,\n            0xe4, 0x40,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n}\n","path":"std/hash/keccak.nr"},"28":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"34":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8 = 256;\nglobal TWO_POW_16 = TWO_POW_8 * 256;\nglobal TWO_POW_24 = TWO_POW_16 * 256;\nglobal TWO_POW_32 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"69":{"source":"fn is_element_in_set(element: Field, set: [Field; 50]) -> bool {\n    let mut result: bool = false;\n    for i in 0..set.len() {\n        if (element == set[i]) {\n            result = true;\n        }\n    }\n    result\n}\n\nfn main(address_u8: [u8; 20],\n        address_field: Field,\n        address_owners: [Field; 50],\n        pub_key_x: [u8;32], pub_key_y: [u8;32],\n        signature: [u8;64],\n        hashed_message: [u8; 32],\n        expected_message: [u8; 38] // Should change to 1 for \"X\"\n){\n     // Check inclusion\n     assert(is_element_in_set(address_field, address_owners));\n\n     // Check address coincidence\n      let mut reconstructed_address: Field = 0;\n      for i in 0..address_u8.len() {\n          reconstructed_address = (reconstructed_address * 256) + (address_u8[i] as Field);\n      }\n      assert(address_field == reconstructed_address);\n\n     // Check message coincidence\n     assert(std::hash::sha256_var(expected_message, 38) == hashed_message);\n\n     // Verifies that the prover is owner of the private key\n     // Prover is requested to send the message \"X\" hashed, so it might be possible to use a hardcoded hashed_message\n\n      let valid_signature = std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, signature, hashed_message);\n      assert(valid_signature);\n\n     //Verifies that the prover's public key derives to the address\n      let mut full_public_key: [u8; 64] = [0; 64];\n      for i in 0..32 {\n          full_public_key[i] = pub_key_x[i];\n      }\n      for i in 0..32 {\n          full_public_key[32 + i] = pub_key_y[i];\n      }\n      let hash = std::hash::keccak256(full_public_key, 64);\n      let mut derived_address: [u8; 20] = [0; 20];\n      for i in 0..20 {\n          derived_address[i] = hash[12+i];\n      }\n      assert(address_u8 == derived_address);\n}\n\n#[test]\nfn test() {\n    let expected_message = [0x49, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x75, 0x6e, 0x63, 0x6c, 0x65, 0x61, 0x72, 0x2c, 0x20, 0x61, 0x73, 0x6b, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x2e, ];\n    let address_field = 0x4cceba2d7d2b4fdce4304d3e09a1fea9fbeb1528;\n    let address_owners = [\n        1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x4cceba2d7d2b4fdce4304d3e09a1fea9fbeb1528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    ];\n\n    let address_u8 =[76, 206, 186, 45, 125, 43, 79, 220, 228, 48, 77, 62, 9, 161, 254, 169, 251, 235, 21, 40];\n    let hashed_message = [ 0x3a, 0x73, 0xf4, 0x12, 0x3a, 0x5c, 0xd2, 0x12, 0x1f, 0x21, 0xcd, 0x7e, 0x8d, 0x35, 0x88, 0x35, 0x47, 0x69, 0x49, 0xd0, 0x35, 0xd9, 0xc2, 0xda, 0x68, 0x06, 0xb4, 0x63, 0x3a, 0xc8, 0xc1, 0xe2, ];\n    let pub_key_x = [ 0xa0, 0x43, 0x4d, 0x9e, 0x47, 0xf3, 0xc8, 0x62, 0x35, 0x47, 0x7c, 0x7b, 0x1a, 0xe6, 0xae, 0x5d, 0x34, 0x42, 0xd4, 0x9b, 0x19, 0x43, 0xc2, 0xb7, 0x52, 0xa6, 0x8e, 0x2a, 0x47, 0xe2, 0x47, 0xc7, ];\n    let pub_key_y = [ 0x89, 0x3a, 0xba, 0x42, 0x54, 0x19, 0xbc, 0x27, 0xa3, 0xb6, 0xc7, 0xe6, 0x93, 0xa2, 0x4c, 0x69, 0x6f, 0x79, 0x4c, 0x2e, 0xd8, 0x77, 0xa1, 0x59, 0x3c, 0xbe, 0xe5, 0x3b, 0x03, 0x73, 0x68, 0xd7, ];\n    let signature = [ 0xe5, 0x08, 0x1c, 0x80, 0xab, 0x42, 0x7d, 0xc3, 0x70, 0x34, 0x6f, 0x4a, 0x0e, 0x31, 0xaa, 0x2b, 0xad, 0x8d, 0x97, 0x98, 0xc3, 0x80, 0x61, 0xdb, 0x9a, 0xe5, 0x5a, 0x4e, 0x8d, 0xf4, 0x54, 0xfd, 0x28, 0x11, 0x98, 0x94, 0x34, 0x4e, 0x71, 0xb7, 0x87, 0x70, 0xcc, 0x93, 0x1d, 0x61, 0xf4, 0x80, 0xec, 0xbb, 0x0b, 0x89, 0xd6, 0xeb, 0x69, 0x69, 0x01, 0x61, 0xe4, 0x9a, 0x71, 0x5f, 0xcd, 0x55, ];\n\n    main(address_u8, address_field, address_owners, pub_key_x, pub_key_y, signature, hashed_message, expected_message);\n}\n\n#[test(should_fail)]\nfn test_fail() {\n    let expected_message = [0x49, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x75, 0x6e, 0x63, 0x6c, 0x65, 0x61, 0x72, 0x2c, 0x20, 0x61, 0x73, 0x6b, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x2e, ];\n    let address_field = 0x4cceba2d7d2b4fdce4304d9e09a1fea9fbeb1528;\n    let address_owners = [\n        1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x4cceba2d7d2b4fdce4304d3e09a1fea9fbeb1528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    ];\n\n    let address_u8 =[76, 206, 186, 45, 125, 43, 79, 220, 228, 48, 77, 62, 9, 161, 254, 169, 251, 235, 21, 40];\n    let hashed_message = [ 0x3a, 0x73, 0xf4, 0x12, 0x3a, 0x5c, 0xd2, 0x12, 0x1f, 0x21, 0xcd, 0x7e, 0x8d, 0x35, 0x88, 0x35, 0x47, 0x69, 0x49, 0xd0, 0x35, 0xd9, 0xc2, 0xda, 0x68, 0x06, 0xb4, 0x63, 0x3a, 0xc8, 0xc1, 0xe2, ];\n    let pub_key_x = [ 0xa0, 0x43, 0x4d, 0x9e, 0x47, 0xf3, 0xc8, 0x62, 0x35, 0x47, 0x7c, 0x7b, 0x1a, 0xe6, 0xae, 0x5d, 0x34, 0x42, 0xd4, 0x9b, 0x19, 0x43, 0xc2, 0xb7, 0x52, 0xa6, 0x8e, 0x2a, 0x47, 0xe2, 0x47, 0xc7, ];\n    let pub_key_y = [ 0x89, 0x3a, 0xba, 0x42, 0x54, 0x19, 0xbc, 0x27, 0xa3, 0xb6, 0xc7, 0xe6, 0x93, 0xa2, 0x4c, 0x69, 0x6f, 0x79, 0x4c, 0x2e, 0xd8, 0x77, 0xa1, 0x59, 0x3c, 0xbe, 0xe5, 0x3b, 0x03, 0x73, 0x68, 0xd7, ];\n    let signature = [ 0xe5, 0x08, 0x1c, 0x80, 0xab, 0x42, 0x7d, 0xc3, 0x70, 0x34, 0x6f, 0x4a, 0x0e, 0x31, 0xaa, 0x2b, 0xad, 0x8d, 0x97, 0x98, 0xc3, 0x80, 0x61, 0xdb, 0x9a, 0xe5, 0x5a, 0x4e, 0x8d, 0xf4, 0x54, 0xfd, 0x28, 0x11, 0x98, 0x94, 0x34, 0x4e, 0x71, 0xb7, 0x87, 0x70, 0xcc, 0x93, 0x1d, 0x61, 0xf4, 0x80, 0xec, 0xbb, 0x0b, 0x89, 0xd6, 0xeb, 0x69, 0x69, 0x01, 0x61, 0xe4, 0x9a, 0x71, 0x5f, 0xcd, 0x55, ];\n\n    main(address_u8, address_field, address_owners, pub_key_x, pub_key_y, signature, hashed_message, expected_message);\n}","path":"/home/bweisz/Documentos/devcon/proof-of-poap-circuits/circuits/src/main.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","directive_invert","directive_integer_quotient"]}