fn is_element_in_set(element: Field, set: [Field; 50]) -> bool {
    let mut result: bool = false;
    for i in 0..set.len() {
        if (element == set[i]) {
            result = true;
        }
    }
    result
}

fn main(address_u8: [u8; 20],
        address_field: Field,
        address_owners: pub [Field; 50],
        pub_key_x: [u8;32],
        pub_key_y: [u8;32],
        signature: [u8;64],
        hashed_message: pub [u8; 32],
        expected_message: pub [u8; 38] // Should change to 1 for "X"
){
     // Check inclusion
     assert(is_element_in_set(address_field, address_owners));

     // Check address coincidence
      let mut reconstructed_address: Field = 0;
      for i in 0..address_u8.len() {
          reconstructed_address = (reconstructed_address * 256) + (address_u8[i] as Field);
      }
      assert(address_field == reconstructed_address);

     // Check message coincidence
     assert(std::hash::sha256_var(expected_message, 38) == hashed_message);

     // Verifies that the prover is owner of the private key
     // Prover is requested to send the message "X" hashed, so it might be possible to use a hardcoded hashed_message

      let valid_signature = std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, signature, hashed_message);
      assert(valid_signature);

     //Verifies that the prover's public key derives to the address
      let mut full_public_key: [u8; 64] = [0; 64];
      for i in 0..32 {
          full_public_key[i] = pub_key_x[i];
      }
      for i in 0..32 {
          full_public_key[32 + i] = pub_key_y[i];
      }
      let hash = std::hash::keccak256(full_public_key, 64);
      let mut derived_address: [u8; 20] = [0; 20];
      for i in 0..20 {
          derived_address[i] = hash[12+i];
      }
      assert(address_u8 == derived_address);
}

#[test]
fn test() {
    let expected_message = [0x49, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x75, 0x6e, 0x63, 0x6c, 0x65, 0x61, 0x72, 0x2c, 0x20, 0x61, 0x73, 0x6b, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x2e, ];
    let address_field = 0x4cceba2d7d2b4fdce4304d3e09a1fea9fbeb1528;
    let address_owners = [
        1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x4cceba2d7d2b4fdce4304d3e09a1fea9fbeb1528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];

    let address_u8 =[76, 206, 186, 45, 125, 43, 79, 220, 228, 48, 77, 62, 9, 161, 254, 169, 251, 235, 21, 40];
    let hashed_message = [ 0x3a, 0x73, 0xf4, 0x12, 0x3a, 0x5c, 0xd2, 0x12, 0x1f, 0x21, 0xcd, 0x7e, 0x8d, 0x35, 0x88, 0x35, 0x47, 0x69, 0x49, 0xd0, 0x35, 0xd9, 0xc2, 0xda, 0x68, 0x06, 0xb4, 0x63, 0x3a, 0xc8, 0xc1, 0xe2, ];
    let pub_key_x = [ 0xa0, 0x43, 0x4d, 0x9e, 0x47, 0xf3, 0xc8, 0x62, 0x35, 0x47, 0x7c, 0x7b, 0x1a, 0xe6, 0xae, 0x5d, 0x34, 0x42, 0xd4, 0x9b, 0x19, 0x43, 0xc2, 0xb7, 0x52, 0xa6, 0x8e, 0x2a, 0x47, 0xe2, 0x47, 0xc7, ];
    let pub_key_y = [ 0x89, 0x3a, 0xba, 0x42, 0x54, 0x19, 0xbc, 0x27, 0xa3, 0xb6, 0xc7, 0xe6, 0x93, 0xa2, 0x4c, 0x69, 0x6f, 0x79, 0x4c, 0x2e, 0xd8, 0x77, 0xa1, 0x59, 0x3c, 0xbe, 0xe5, 0x3b, 0x03, 0x73, 0x68, 0xd7, ];
    let signature = [ 0xe5, 0x08, 0x1c, 0x80, 0xab, 0x42, 0x7d, 0xc3, 0x70, 0x34, 0x6f, 0x4a, 0x0e, 0x31, 0xaa, 0x2b, 0xad, 0x8d, 0x97, 0x98, 0xc3, 0x80, 0x61, 0xdb, 0x9a, 0xe5, 0x5a, 0x4e, 0x8d, 0xf4, 0x54, 0xfd, 0x28, 0x11, 0x98, 0x94, 0x34, 0x4e, 0x71, 0xb7, 0x87, 0x70, 0xcc, 0x93, 0x1d, 0x61, 0xf4, 0x80, 0xec, 0xbb, 0x0b, 0x89, 0xd6, 0xeb, 0x69, 0x69, 0x01, 0x61, 0xe4, 0x9a, 0x71, 0x5f, 0xcd, 0x55, ];

    main(address_u8, address_field, address_owners, pub_key_x, pub_key_y, signature, hashed_message, expected_message);
}

#[test(should_fail)]
fn test_fail() {
    let expected_message = [0x49, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x75, 0x6e, 0x63, 0x6c, 0x65, 0x61, 0x72, 0x2c, 0x20, 0x61, 0x73, 0x6b, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x2e, ];
    let address_field = 0x4cceba2d7d2b4fdce4304d9e09a1fea9fbeb1528;
    let address_owners = [
        1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x4cceba2d7d2b4fdce4304d3e09a1fea9fbeb1528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];

    let address_u8 =[76, 206, 186, 45, 125, 43, 79, 220, 228, 48, 77, 62, 9, 161, 254, 169, 251, 235, 21, 40];
    let hashed_message = [ 0x3a, 0x73, 0xf4, 0x12, 0x3a, 0x5c, 0xd2, 0x12, 0x1f, 0x21, 0xcd, 0x7e, 0x8d, 0x35, 0x88, 0x35, 0x47, 0x69, 0x49, 0xd0, 0x35, 0xd9, 0xc2, 0xda, 0x68, 0x06, 0xb4, 0x63, 0x3a, 0xc8, 0xc1, 0xe2, ];
    let pub_key_x = [ 0xa0, 0x43, 0x4d, 0x9e, 0x47, 0xf3, 0xc8, 0x62, 0x35, 0x47, 0x7c, 0x7b, 0x1a, 0xe6, 0xae, 0x5d, 0x34, 0x42, 0xd4, 0x9b, 0x19, 0x43, 0xc2, 0xb7, 0x52, 0xa6, 0x8e, 0x2a, 0x47, 0xe2, 0x47, 0xc7, ];
    let pub_key_y = [ 0x89, 0x3a, 0xba, 0x42, 0x54, 0x19, 0xbc, 0x27, 0xa3, 0xb6, 0xc7, 0xe6, 0x93, 0xa2, 0x4c, 0x69, 0x6f, 0x79, 0x4c, 0x2e, 0xd8, 0x77, 0xa1, 0x59, 0x3c, 0xbe, 0xe5, 0x3b, 0x03, 0x73, 0x68, 0xd7, ];
    let signature = [ 0xe5, 0x08, 0x1c, 0x80, 0xab, 0x42, 0x7d, 0xc3, 0x70, 0x34, 0x6f, 0x4a, 0x0e, 0x31, 0xaa, 0x2b, 0xad, 0x8d, 0x97, 0x98, 0xc3, 0x80, 0x61, 0xdb, 0x9a, 0xe5, 0x5a, 0x4e, 0x8d, 0xf4, 0x54, 0xfd, 0x28, 0x11, 0x98, 0x94, 0x34, 0x4e, 0x71, 0xb7, 0x87, 0x70, 0xcc, 0x93, 0x1d, 0x61, 0xf4, 0x80, 0xec, 0xbb, 0x0b, 0x89, 0xd6, 0xeb, 0x69, 0x69, 0x01, 0x61, 0xe4, 0x9a, 0x71, 0x5f, 0xcd, 0x55, ];

    main(address_u8, address_field, address_owners, pub_key_x, pub_key_y, signature, hashed_message, expected_message);
}